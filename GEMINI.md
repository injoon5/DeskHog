# Gemini Code Analysis: DeskHog

This document provides a comprehensive analysis of the DeskHog project, generated by Gemini. It is intended to be a technical guide for developers and AI agents working on the codebase.

## Project Overview

DeskHog is an open-source, 3D-printed, palm-sized developer toy built around the Adafruit ESP32-S3 Reverse TFT Feather. It features a 240x135 color TFT display, Wi-Fi connectivity, and a rechargeable battery. The device's primary function is to display a series of "cards," which are individual screens that can show information, play games, or provide other interactive experiences.

The project is designed to be highly extensible, with a focus on making it easy for developers to create and add their own custom cards. DeskHog is also optimized for development with AI agents, with clear documentation and a well-structured codebase that is conducive to AI-assisted coding.

## Hardware

*   **Microcontroller:** Adafruit ESP32-S3 Reverse TFT Feather
*   **Display:** 240x135 Color TFT Display
*   **Connectivity:** Wi-Fi
*   **Power:** PKCell 552035 350mAh 3.7V LiPoly battery (optional)
*   **Enclosure:** 3D-printed custom case

## Software Architecture

The DeskHog firmware is written in C++ using the Arduino framework and PlatformIO. It employs a sophisticated dual-core, multi-tasking architecture to ensure smooth performance and stability.

### Core and Task Isolation

The ESP32-S3 has two cores, and the DeskHog firmware takes full advantage of them by assigning specific tasks to each core. This separation of concerns is crucial for preventing crashes and ensuring that the UI remains responsive at all times.

*   **Core 0 (Protocol CPU):** This core is responsible for handling all networking and background tasks, including:
    *   Wi-Fi communication
    *   Running the web portal server
    *   Parsing data from the PostHog API
    *   Controlling the NeoPixel LED

*   **Core 1 (Application CPU):** This core is dedicated to the user interface and input handling:
    *   Running the LVGL graphics library tick, which manages timing and animations
    *   Drawing the UI and handling all screen updates
    *   Processing input from the device's buttons

### Event Queue

To facilitate safe communication between the two cores, the firmware uses an `EventQueue`. This is a classic message queue that allows tasks on different cores to send and receive events without directly accessing each other's memory. This is essential for preventing race conditions and other concurrency-related bugs.

When a task on Core 0 needs to update the UI (e.g., after receiving new data from the network), it dispatches an event to the `EventQueue`. The UI task on Core 1 then receives the event and updates the screen accordingly.

## UI System

The user interface is built using the powerful [LVGL (Light and Versatile Graphics Library)](https://lvgl.io/). LVGL is a feature-rich graphics library that is well-suited for embedded systems with limited resources.

### Card System

The DeskHog UI is organized into a stack of "cards." Each card is a self-contained screen that can display information, play a game, or provide some other form of interaction. The user can navigate between cards using the device's buttons.

The card system is managed by two key classes:

*   **`CardNavigationStack`:** This class is responsible for managing the presentation of the cards, including animating transitions between them.
*   **`CardController`:** This class manages the contents of the card stack. It handles adding, removing, and reordering cards based on user input from the web portal.

### Creating New Card Types

The DeskHog firmware is designed to be easily extensible with new card types. To create a new card, you need to:

1.  **Add a new value to the `CardType` enum:** This enum, located in `src/ui/CardController.h`, uniquely identifies each type of card.
2.  **Create a new card class:** This class will be responsible for creating and managing the UI for your card using LVGL.
3.  **Register the new card type:** In the `CardController::initializeCardTypes()` method, you need to register your new card type by providing a `CardDefinition` struct. This struct contains information about your card, such as its name, description, and a factory function that creates new instances of the card.
4.  **Implement an `InputHandler` (optional):** If your card needs to be updated regularly (e.g., for a game or animation), you can implement the `InputHandler` interface. This will allow your card to receive regular updates from the UI system.

## Configuration and Provisioning

DeskHog uses a web-based captive portal for initial Wi-Fi provisioning and ongoing device configuration. When the device is first powered on, it creates a Wi-Fi access point that the user can connect to. Once connected, the user can open a web browser to access the captive portal.

The portal allows the user to:

*   Configure the device's Wi-Fi credentials
*   Add, remove, and reorder cards
*   Configure the settings for individual cards (e.g., PostHog insight IDs)

The HTML, CSS, and JavaScript for the portal are located in the `html/` directory. These files are converted into a single C header file (`include/html_portal.h`) by the `htmlconvert.py` script during the build process. This allows the portal to be served directly from the device's flash memory, without requiring an internet connection.

## Firmware Updates

DeskHog supports Over-the-Air (OTA) firmware updates using GitHub Releases. The device can check for new firmware versions on GitHub and, if a new version is available, download and install it automatically.

The OTA update process is managed by the `OtaManager` class. This class is responsible for:

*   Checking for new firmware versions on GitHub
*   Downloading the new firmware binary
*   Writing the new firmware to the inactive partition of the ESP32's flash memory
*   Triggering a reboot to apply the update

## Asset Management

The DeskHog firmware uses several Python scripts to convert and embed assets (such as images, fonts, and HTML files) into the firmware. These scripts are run automatically during the build process, so any changes to the assets will be reflected in the next build.

*   **`png2c.py`:** This script converts PNG images into LVGL-compatible C arrays. This makes it easy to add sprite-based animations and graphics to the device.
*   **`ttf2c.py`:** This script converts TTF fonts into LVGL-compatible C arrays. This allows you to use custom fonts in your UI.
*   **`htmlconvert.py`:** This script converts the HTML, CSS, and JavaScript files for the captive portal into a single C header file.

## Key Files and Directories

*   **`src/`:** This directory contains all of the C++ source code for the firmware.
    *   **`main.cpp`:** The main entry point for the application.
    *   **`ui/`:** Contains the source code for the UI system, including the `CardController` and `CardNavigationStack`.
    *   **`hardware/`:** Contains the source code for interacting with the device's hardware, such as the display and buttons.
    *   **`posthog/`:** Contains the source code for interacting with the PostHog API.
*   **`include/`:** This directory contains all of the header files for the firmware.
*   **`html/`:** This directory contains the source files for the web-based captive portal.
*   **`raw-png/`:** This directory contains the raw PNG images that are converted into C arrays by the `png2c.py` script.
*   **`typography/`:** This directory contains the TTF fonts that are converted into C arrays by the `ttf2c.py` script.
*   **`platformio.ini`:** The PlatformIO configuration file. This file defines the build environment, dependencies, and other project settings.

## Development Workflow

To develop for DeskHog, you will need to have PlatformIO installed. You can then use the following workflow:

1.  **Clone the repository:** `git clone https://github.com/PostHog/DeskHog.git`
2.  **Open the project in your favorite editor:** We recommend using Visual Studio Code with the PlatformIO extension.
3.  **Make your changes:** You can modify the existing code or add new features, such as new card types.
4.  **Build and flash the firmware:** You can use the PlatformIO CLI or the Visual Studio Code extension to build the firmware and flash it to the device.

## AI-Assisted Development

The DeskHog project is optimized for development with AI agents. The codebase is well-structured and well-documented, and the documentation includes specific guidance on how to use AI to write code for the project.

When working with an AI agent, it is important to:

*   **Provide the agent with the right context:** Give the agent access to the relevant documentation and source code.
*   **Encourage the agent to follow existing patterns:** The DeskHog codebase has a number of well-established patterns, such as the use of the `EventQueue` for cross-core communication. Encourage the agent to follow these patterns to ensure that the code it produces is correct and efficient.
*   **Review and test the agent's code thoroughly:** AI agents are powerful tools, but they are not perfect. It is important to review and test the code that they produce to ensure that it is correct and does not contain any bugs.
